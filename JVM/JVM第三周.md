[toc]



# 什么情况下对象会被垃圾回收

## 被哪些变量引用的对象是不能被回收的

JVM采用**可达性分析算法**来判定哪些对象是可以被回收的，哪些对象不可以被回收

> 对每一个对象，都分析谁在引用他，然后一层一层往上面判断，看是否有**GC Roots**

只要你的对象被方法的局部变量和类的静态变量（**GC Roots**）引用了，就不会回收他们

## Java中对象不同的引用类型

强引用、软引用、弱引用和虚引用

+ 强引用对象永远不会被垃圾回收
+ 软引用对象在正常垃圾回收情况下不会被回收，如果进行垃圾回收后发现内存空间还是不够放新的对象，内存快要溢出了，此时就会把软引用对象回收掉（哪怕它被变量引用了，但因为它是软引用，所以还要被回收）
  + 软引用是说有的对象可有可无，如果内存不够了，就回收它

+ 弱引用对象只要发生GC，就会被回收掉

# JVM中有哪些回收算法（算法的优劣）

## 复制算法

**初始版复制算法**

> 将内存空间分为两块，一块存对象，另一块初始为空

1. 标记哪些对象存活
2. 将存活对象移动到另一块空间中（对象紧凑，不易产生内存碎片）
3. 然后将垃圾对象所在空间中的垃圾全部清除

缺点： 永远有一个内存空间是空的，导致整体内存利用率不高

**改进版复制算法**

将新生代区域分为三块（一块Eden区，两块Survivor区），Eden区占据80%，每块Survivor区占10%

**平时使用Eden区和一块Survivor区**

+ 刚开始对象都在Eden区域,Eden区满了就会触发垃圾回收(Monor GC)，此时会将Eden区的存活对象转移到空着的Survivor区，接着Survivor区被清空
+ 然后程序运行，Eden区又多了很多对象，出发垃圾回收(Minor GC)，此时Eden区和一块Survivor区存活的对象会被移动到另一块空着的Survivor区（Eden区和另一个Survivor区的对象会被清除）

这样做的好处是，不用浪费那么多内存空间，正常只会空闲10%的Survivor区

这种算法尤其适合新生代的垃圾回收，因为新生代中的对象存活周期较短

> 第一次gc: eden区满后将存活的对象复制到survivor from区域,清空eden区 
>
> 第二次gc: eden区满后将eden区存活的对象和survivor from区存活的对象,一起复制到survivor to区域,然后进行from和to区域的交换即survivor from存储活着的,survivor to为空 
>
> 第三次gc: eden区满后同第二次将eden区存活的和survivor from存活的,复制到survivor to在交换from和to的指针

## 标记清除算法

缺点：产生大量的内存碎片

> 内存碎片会造成内存浪费，因为碎片太小，无法容量一个新对象

## 思考题TODO

+ 每秒钟系统会使用多少内存，多长时间会触发一次垃圾回收？
+ 垃圾回收之后，你们系统内大约会有多少对象存活下来？

# 对象如何进入老年代

1. 躲过15次Minor GC后进入老年代

2. 大对象直接进入老年代 > 1MB

   > 复制来复制去没意思

3. Minor GC后的对象太多无法放进Survivor

   > 如果此时老年代也放不下了呢？

   + 首先，年轻代在每一次Minor GC之前，JVM会检查一下老年代可用的内存大小，是否大于新生代所有对象的总大小

   + 因为最极端情况是，MinorGC后所有对象全部存活了下来，那么新生代所有对象可能都会进入老年代

   + 如果老年代可用内存大于新生代所有对象的总大小，就可以放心去GC，因为即使最极端的情况，老年代也能够容纳新生代GC存活下来的对象

   + 如果反之，老年代可用内存小于新生代的全部对象大小了，就会去寻找` -XX:HandlePromotionFailure`参数是否设置
   + 如果设置了该参数，判断老年代的内存大小是否大于之前每一次Minor GC后进入老年代的对象平均大小(10MB)
     + 大于 ，说明很可能这一次Minor GC后也是10MB左右的对象会进入老年代，老年代空间是足够的
       + 1. Minor GC后，剩余存活对象大小小于Survivor区，直接进入Survivor
         2. 大于Survivor区，但是小于老年代可用内存大小的，直接进入老年代
         3. 大于Survivor区，同时大于老年代可用内存大小的，老年代放不下了，直接Full GC
            1. 老年代必须GC，腾出空间来给新生代存活下来的对象
            2. 如果此时Full GC后，老年代还是没有足够的空间存放，直接OOM
     + 小于  Full GC
   + 如果没设置该参数，此时会触发一次Full GC

   ![](https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/6292_4x9oVvEq_03_对象从年轻代晋升至老年代.png)

   > FullGC指的是老年代和年轻代同时GC
   
   

# 老年代垃圾回收算法

## 老年代垃圾回收时机

1. Minor GC前，发现要进入老年代的对象太多了，老年代空间放不下了，所以提前触发FullGC，然后再进行Minor GC
2. Minor GC之后，发现存活对象放进老年代放不下了，就Full GC

## 标记整理算法

1. 标记存活对象
2. 让存活对象在内存中移动，尽量将存活对象移到一边，让存活对象紧凑在一起，避免垃圾回收后产生过多的内存碎片
3. 把垃圾对象全部回收掉

> 老年代的垃圾回收算法速度比新生代的垃圾回收算法至少慢10倍
> 如果系统频繁出现Full GC，会导致系统性能被严重影响，出现频繁卡顿的情况
> 所谓的JVM优化，就是尽可能让对象都在新生代空间分配和回收，尽量别让太多对象进入老年代，避免频繁对老年代对象进行垃圾回收，同时给系统充足的内存大小，避免新生代进行频繁的垃圾回收

# Stop the World

> 垃圾回收工作其实是垃圾回收线程通过垃圾回收器使用一定的垃圾回收算法进行垃圾回收

+ 垃圾回收线程
+ 垃圾回收器
+ 垃圾回收算法

垃圾回收时，尽可能让垃圾回收器专心致志的工作，不能随便让我们的Java系统继续创建对象

> 此时JVM会在后台直接进入Stop the World 状态

Stop  the World 会造成系统卡顿，