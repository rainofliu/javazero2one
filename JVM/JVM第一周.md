[toc]



# 前言

JVM学习的痛点：

1. 生产环境OOM

2. 系统经常性卡顿，是否进行了Full GC

3. 面试经常问实战经验，对于这一块几乎为0，只知道理论上的JVM内存结构、垃圾回收算法还远远不够

   > 只掌握理论知识没有实践，等于没有掌握所学知识！

JVM学习的目标：

1. 对自己负责的系统，可以进行生产级别的**JVM参数优化**
2. 线上遇到生产故障，有系统化的思路去分析、排查和定位
3. 可以动手实践，明白背后的JVM底层原理

# Java代码到底是如何运行起来的

![](https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/Java代码如何运行.png)

+ .java源文件被打包成jar包  
  + .java   -> .class 
  + 编译过程
+ 谁来运行jar包 
  + JVM 
    + 借助**“类加载器”**将一个个class字节码文件加载进JVM中
      + class文件就是我们编写好的一个个类文件
    + 加载好以后，JVM会基于自己的**“字节码执行引擎”**，来执行加载到内存中的类

> 以上就是对 java -jar  xxx.jar命令的简要说明；java -jar命令会启动一个JVM进程

## 作业

> .java文件可以被编译成.class文件，反之.class文件也可以被反编译成.java文件

但是这样的话，如果你们公司的系统代码编译好之后，都是“.class”的格式，但是被别人拿到了，反编译回来不就可以窃取你们公司的核心系统的源代码了？对这个问题，大家觉得应该怎么解决呢？

+ 首先你编译时，就可以采用一些小工具对字节码加密，或者做混淆等处理
+ 然后在类加载的时候，对加密的类，考虑采用自定义的类加载器来解密文件即可，这样就可以保证你的源代码不被人

# JVM类加载机制

## JVM什么情况下会加载一个类

在你的代码用到这个类的时候

```java
public class Application{
    public static void main(String[] args){
        B b=new B();
    }
}
```

假设Application类中的main方法是JVM进程启动就运行的，首先需要将Application.class加载到内存中，然后才从main方法入口执行，此时我们需要new B对象，因此我们还需要从B.class字节码文件加载对应的类到内存中来，这样代码才能跑起来

## 类加载过程

一个类从加载到使用经历的过程：加载 -> 验证 -> 准备 -> 解析 -> 初始化  -> 使用  -> 卸载

### 验证

根据Java虚拟机规范，校验我们加载进来的".class"文件中的内容，是否合乎规范

### 准备

```java
public class B{
    private static int value;
}
```

+ 给B类分配一定的空间
+ 给类变量分配一定的空间，并设置默认的初始值

### 解析（TO）

**将符号引用替换为直接引用**

### 初始化

+ 初始化静态变量
+ 执行静态代码块

**什么时候会初始化一个类？**

> 疑惑

## 类加载器和双亲委派机制

### 类加载器

### (启动类加载器）Bootstrap ClassLoader

JVM启动时，首先会委托启动类加载器，去加载jdk lib下的核心类库

#### （扩展类加载器） Extension ClassLoader

JVM启动时，首先会委托启动类加载器，去加载jdk lib\ext下的核心类库

#### (应用程序类加载器)Application ClassLoader

加载classpath下的类，我们编写的应用程序代码

#### （自定义类加载器）

### 双亲委派机制

![](https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/类加载图示.png)

## Tomcat中的类加载机制(?)

Tomcat中的类加载器应该如何设计，才能**动态把我们部署的war包中的类，加载到Tomcat自身运行的JVM中**，然后去执行那些我们写好的Java代码？

![](https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/Tomcat类加载.png)

Tomcat自定义了Common、Catalina、Shared等类加载器，其实就是用来加载Tomcat自己的一些核心基础类库的。
然后Tomcat为每个部署在里面的Web应用都有一个对应的WebApp类加载器，负责加载我们部署的这个Web应用的类至于Jsp类加载器，则是给每个JSP都准备了一个Jsp类加载器。
而且大家一定要记得，Tomcat是打破了双亲委派机制的
每个WebApp负责加载自己对应的那个Web应用的class文件，也就是我们写好的某个系统打包好的war包中的所有class文件，不会传导给上层类加载器去加载。



# JVM内存结构

> 大厂面试题：JVM中有哪些内存区域，分别都是用来干嘛的

JVM在运行我们写好的代码时，它是必须使用多块内存空间的，不同的空间用来放不同的数据

> ClassLoader将class类文件加载进JVM的内存中，类文件都去哪儿了呢？

## 存放类的方法区

方法区在JDK1.8以前，存放从".class"文件中加载进来的类，还会存储一些常量池。

JDK1.8依赖，这个区域改名叫Metaspace(元数据空间)，主要还是存放类相关信息。

## 执行代码用的程序计数器

我们写好的".java"源文件，计算机理解不了，需要编译成".class"文件才可以理解。

> 我们写好的Java代码会被翻译成字节码，对应各种字节码指令
>
> + 所以说JVM加载类信息到内存之后，就会使用自己的“字节码执行引擎”，去执行字节码指令
> + **在执行字节码指令时，需要“程序计数器”记录当前执行的字节码指令的位置**
>   + 记录目前执行到哪一行指令

JVM是支持多线程的，会有多个线程并发地执行不同的字节码指令，因此每个线程都有自己的程序计数器，记录当前线程执行到了哪一行指令了。

**线程私有，非共享**

## Java虚拟机栈

**每个线程都有自己的虚拟机栈**

+ 方法的局部变量表
+  操作数栈
+ 动态链接
+ 方法出口

当一个线程执行方法时，每执行一个方法，就会创建一个栈帧，用来存放每个方法的局部变量表等信息，方法执行完毕就会出栈

## Java堆内存

线程共享，存储对象

+ 堆内存分配的对象，到底会占用多少空间？

+ 怎么计算和估算系统创建的对象对内存占用的压力？

# Java垃圾回收机制作用

内存资源有限，需要回收没用的对象

# 第一周作业：JVM运行原理图

![](https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/6292_UA2EuFOQ_JVM整体运行原理图.png)

# 查漏补缺

静态变量 存在方法区，静态变量如果是引用，则其对应的对象会保存在堆内存中

静态变量是共享的类对象的属性，必然不可能放在虚拟机栈中

