[toc]



# 前言

JVM学习的痛点：

1. 生产环境OOM

2. 系统经常性卡顿，是否进行了Full GC

3. 面试经常问实战经验，对于这一块几乎为0，只知道理论上的JVM内存结构、垃圾回收算法还远远不够

   > 只掌握理论知识没有实践，等于没有掌握所学知识！

JVM学习的目标：

1. 对自己负责的系统，可以进行生产级别的**JVM参数优化**
2. 线上遇到生产故障，有系统化的思路去分析、排查和定位
3. 可以动手实践，明白背后的JVM底层原理

# Java代码到底是如何运行起来的

![](https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/Java代码如何运行.png)

+ .java源文件被打包成jar包  
  + .java   -> .class 
  + 编译过程
+ 谁来运行jar包 
  + JVM 
    + 借助**“类加载器”**将一个个class字节码文件加载进JVM中
      + class文件就是我们编写好的一个个类文件
    + 加载好以后，JVM会基于自己的**“字节码执行引擎”**，来执行加载到内存中的类

> 以上就是对 java -jar  xxx.jar命令的简要说明；java -jar命令会启动一个JVM进程

## 作业

> .java文件可以被编译成.class文件，反之.class文件也可以被反编译成.java文件

但是这样的话，如果你们公司的系统代码编译好之后，都是“.class”的格式，但是被别人拿到了，反编译回来不就可以窃取你们公司的核心系统的源代码了？对这个问题，大家觉得应该怎么解决呢？

+ 首先你编译时，就可以采用一些小工具对字节码加密，或者做混淆等处理
+ 然后在类加载的时候，对加密的类，考虑采用自定义的类加载器来解密文件即可，这样就可以保证你的源代码不被人

# JVM类加载机制

## JVM什么情况下会加载一个类

在你的代码用到这个类的时候

```java
public class Application{
    public static void main(String[] args){
        B b=new B();
    }
}
```

假设Application类中的main方法是JVM进程启动就运行的，首先需要将Application.class加载到内存中，然后才从main方法入口执行，此时我们需要new B对象，因此我们还需要从B.class字节码文件加载对应的类到内存中来，这样代码才能跑起来

## 类加载过程

一个类从加载到使用经历的过程：加载 -> 验证 -> 准备 -> 解析 -> 初始化  -> 使用  -> 卸载

### 验证

根据Java虚拟机规范，校验我们加载进来的".class"文件中的内容，是否合乎规范

### 准备

```java
public class B{
    private static int value;
}
```

+ 给B类分配一定的空间
+ 给类变量分配一定的空间，并设置默认的初始值

### 解析（TO）

**将符号引用替换为直接引用**

### 初始化

+ 初始化静态变量
+ 执行静态代码块

**什么时候会初始化一个类？**

> 疑惑

## 类加载器和双亲委派机制

### 类加载器

### (启动类加载器）Bootstrap ClassLoader

JVM启动时，首先会委托启动类加载器，去加载jdk lib下的核心类库

#### （扩展类加载器） Extension ClassLoader

JVM启动时，首先会委托启动类加载器，去加载jdk lib\ext下的核心类库

#### (应用程序类加载器)Application ClassLoader

加载classpath下的类，我们编写的应用程序代码

#### （自定义类加载器）

### 双亲委派机制

![](https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/类加载图示.png)

## Tomcat中的类加载机制(?)

Tomcat中的类加载器应该如何设计，才能**动态把我们部署的war包中的类，加载到Tomcat自身运行的JVM中**，然后去执行那些我们写好的Java代码？

![](https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/Tomcat类加载.png)

Tomcat自定义了Common、Catalina、Shared等类加载器，其实就是用来加载Tomcat自己的一些核心基础类库的。
然后Tomcat为每个部署在里面的Web应用都有一个对应的WebApp类加载器，负责加载我们部署的这个Web应用的类至于Jsp类加载器，则是给每个JSP都准备了一个Jsp类加载器。
而且大家一定要记得，Tomcat是打破了双亲委派机制的
每个WebApp负责加载自己对应的那个Web应用的class文件，也就是我们写好的某个系统打包好的war包中的所有class文件，不会传导给上层类加载器去加载。



# JVM内存结构

> 大厂面试题：JVM中有哪些内存区域，分别都是用来干嘛的

JVM在运行我们写好的代码时，它是必须使用多块内存空间的，不同的空间用来放不同的数据

> ClassLoader将class类文件加载进JVM的内存中，类文件都去哪儿了呢？

## 存放类的方法区

方法区在JDK1.8以前，存放从".class"文件中加载进来的类，还会存储一些常量池。

JDK1.8依赖，这个区域改名叫Metaspace(元数据空间)，主要还是存放类相关信息。

## 执行代码用的程序计数器

我们写好的".java"源文件，计算机理解不了，需要编译成".class"文件才可以理解。

> 我们写好的Java代码会被翻译成字节码，对应各种字节码指令
>
> + 所以说JVM加载类信息到内存之后，就会使用自己的“字节码执行引擎”，去执行字节码指令
> + **在执行字节码指令时，需要“程序计数器”记录当前执行的字节码指令的位置**
>   + 记录目前执行到哪一行指令

JVM是支持多线程的，会有多个线程并发地执行不同的字节码指令，因此每个线程都有自己的程序计数器，记录当前线程执行到了哪一行指令了。

**线程私有，非共享**

## Java虚拟机栈

**每个线程都有自己的虚拟机栈**

+ 方法的局部变量表
+  操作数栈
+ 动态链接
+ 方法出口

当一个线程执行方法时，每执行一个方法，就会创建一个栈帧，用来存放每个方法的局部变量表等信息，方法执行完毕就会出栈

## Java堆内存

线程共享，存储对象

+ 堆内存分配的对象，到底会占用多少空间？

+ 怎么计算和估算系统创建的对象对内存占用的压力？

# Java垃圾回收机制作用

内存资源有限，需要回收没用的对象

# 第一周作业：JVM运行原理图

![](https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/6292_UA2EuFOQ_JVM整体运行原理图.png)

# 查漏补缺

静态变量 存在方法区，静态变量如果是引用，则其对应的对象会保存在堆内存中

静态变量是共享的类对象的属性，必然不可能放在虚拟机栈中

# JVM分代模型（年轻代、老年代、永久代）

1. 大部分对象存活周期极短
2. 少数对象是长期存活

## JVM分代模型

+ 年轻代：很快就要被回收的对象
+ 老年代：长期存在的对象
+ 永久代：保存类信息（JDK1.7）

### 对象在JVM中如何分配、流转

1. 大部分正常对象，都优先在新生代分配内存
2. 垃圾回收不是实时的，得满足一定的条件才会触发
   + 新生代内存不足，会触发一次新生代内存空间的垃圾回收（Minor GC / Young GC），会将年轻代里面没人引用的垃圾对象回收掉
3. 长期存活的对象会躲过多次垃圾回收
   + JVM规定，如果一个新生代对象，成功地在15次垃圾回收后，还没有被回收掉，就会被转移到老年代中去
   + 经历一次GC后存活下来的对象，年龄会+1
4. 老年代满了也会发生垃圾回收

**方法区会不会发生垃圾回收**

会，满足下面三个条件，方法区中的类会被回收

+ 该类的所有实例对象都会被回收
+ 加载该类的ClassLoader已经被回收
+ 该类的Class对象没有任何引用

## 课后问题

1. 每个线程都有自己的虚拟机栈，里面也有方法的局部变量表等数据，Java虚拟机栈需要垃圾回收吗？

   > 方法执行完，方法的栈帧直接出栈了，清理啥？？？

2. 你负责的系统中，短生存周期的对象特征有哪些，长生存周期的对象特征有哪些

   > 短： 方法里面的对象，长：Spring Service

# 设置JVM内存大小

1. -Xms : Java堆内存大小
2. -Xmx ： Java堆内存最大大小
3. -Xmn ：Java堆内存中新生代的空间大小，剩余空间为老年代的空间大小
4. -XX:PermSize : 永久代大小
5. -XX: MaxPermSize : 永久代最大大小
6. -Xss：每个线程的栈内存大小

> younggc:执行时间不超过50ms 执行不是很频繁不小于10s一次   fullgc:执行时间不超过1s 执行频率不低于10分钟

## 课后习题

Tomcat、Spring Boot部署启动系统的时候，JVM参数如何设置？

+ Tomcat 

  > Windows下，在文件/bin/catalina.bat，Unix下，在文件/bin/catalina.sh的前面，增加如下设置

+ Spring Boot

  > `java -Xms1024m -Xmx1024m -jar app.jar` 

对象的大小估算：

> 一般实体都是包装类型 对象头(4字节)+引用类型(4字节)+实例数据(integer:4 Long:8)+数据填充(将整个大小补齐为8的倍数)

# 第二周作业：你的线上系统是如何设置JVM参数的

非常简单，希望每个人按照案例里分析的那个过程，把你手头负责的系统的核心业务流程简化、抽象以及梳理出来，看看你们线上的真实负载情况，每秒钟多少请求？

然后根据你们的核心业务流程，看看每秒钟你负责的系统对内存使用的压力有多大？

假如你发现自己负责的系统很Low，没什么压力，那你可以尝试思考一下，如果你系统负载扩大100倍呢？此时对你内存使用压力有多大？

接着你再思考一下，就你的系统内存使用压力之下，目前你们线上机器是多大的堆内存？新生代多大？老年代多大？

如果没设置，可以自行百度默认的内存大小。然后分析一下，目前的这个内存配置，你们的垃圾回收有多频繁？

希望大家对自己手头的系统，严格的去分析一下，这个流程做下来，相信你对JVM的理解，对你负责的系统的理解，对线上系统的内存分配，都会提升一个理解的层次。



我们系统一般是提交一个表单，然后保存到数据库，会涉及到一些审核对象

+ 每秒多少请求？
+ 系统对内存使用的压力有多大？

# 第二周答疑笔记

1. 既然栈帧存放了方法对应的局部变量的数据也包括了方法执行的其它相关信息，那为什么不把程序计算器那块记录执行的情况，也放在各个方法自己的栈帧里，而是要单独列一个程序计数器去存储呢？请教，谢谢

   > 这就是JVM设计者的设计思想了，因为程序计数器针对的是代码指令的执行，Java虚拟栈针对的是放方法的数据，一个是指令，一个是数据，分开设计

2. tomcat需要破坏双亲委派模型的原因：？？？

    (1)tomcat中的需要支持不同web应用依赖同一个第三方类库的不同版本，jar类库需要保证相互隔离；

    (2)同一个第三方类库的相同版本在不同web应用可以共享

    (3)tomcat自身依赖的类库需要与应用依赖的类库隔离 (3)jsp需要支持修改后不用重启tomcat即可生效 为了上面类加载隔离和类更新不用重启，定制开发各种的类加载器

3. 老师我上网查了一下资料，把问题弄明白了。Test.class是被加载了，但是并没有 执行初始化步骤。 

   课程中提到了类加载的时机，但是**没有提到类初始化的时机**，我把一直理解类的 加载->验证->准备->解析->初始化是一个连续的动作，以为类一旦加载必定 会立即初始化。

   补充类初始化的时机如下：

    1.当创建某个类的新实例时（如通过new或者反射，克隆，反序列化等）

    2.当调用某个类的静态方法时

    3.当使用某个类或接口的静态字段时

    4.调用Java API中的某些反射方法时，比如类Class中的方法，或者java.lang.reflect中的类的方法时

    5.当初始化某个子类时

    6.当虚拟机启动某个被标明为启动类的类（即包含main方法的那个类） 所以System.ou.println(Test.class)不满足上面6种情况，也就没有做初始化

# 什么情况下对象会被垃圾回收

## 被哪些变量引用的对象是不能被回收的

JVM采用**可达性分析算法**来判定哪些对象是可以被回收的，哪些对象不可以被回收

> 对每一个对象，都分析谁在引用他，然后一层一层往上面判断，看是否有**GC Roots**

只要你的对象被方法的局部变量和类的静态变量（**GC Roots**）引用了，就不会回收他们

## Java中对象不同的引用类型

强引用、软引用、弱引用和虚引用

+ 强引用对象永远不会被垃圾回收
+ 软引用对象在正常垃圾回收情况下不会被回收，如果进行垃圾回收后发现内存空间还是不够放新的对象，内存快要溢出了，此时就会把软引用对象回收掉（哪怕它被变量引用了，但因为它是软引用，所以还要被回收）
  + 软引用是说有的对象可有可无，如果内存不够了，就回收它

+ 弱引用对象只要发生GC，就会被回收掉

# JVM中有哪些回收算法（算法的优劣）

TODO

