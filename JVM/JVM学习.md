[toc]



# 前言

JVM学习的痛点：

1. 生产环境OOM

2. 系统经常性卡顿，是否进行了Full GC

3. 面试经常问实战经验，对于这一块几乎为0，只知道理论上的JVM内存结构、垃圾回收算法还远远不够

   > 只掌握理论知识没有实践，等于没有掌握所学知识！

JVM学习的目标：

1. 对自己负责的系统，可以进行生产级别的JVM参数优化
2. 线上遇到生产故障，有系统化的思路去分析、排查和定位
3. 可以动手实践，明白背后的JVM底层原理

# Java代码到底是如何运行起来的

![](https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/Java代码如何运行.png)

+ .java源文件被打包成jar包  
  + .java   -> .class 
  + 编译过程
+ 谁来运行jar包 
  + JVM 
    + 借助**“类加载器”**将一个个class字节码文件加载进JVM中
      + class文件就是我们编写好的一个个类文件
    + 加载好以后，JVM会基于自己的**“字节码执行引擎”**，来执行加载到内存中的类

> 以上就是对 java -jar  xxx.jar命令的简要说明；java -jar命令会启动一个JVM进程

## 作业

> .java文件可以被编译成.class文件，反之.class文件也可以被反编译成.java文件

但是这样的话，如果你们公司的系统代码编译好之后，都是“.class”的格式，但是被别人拿到了，反编译回来不就可以窃取你们公司的核心系统的源代码了？对这个问题，大家觉得应该怎么解决呢？

+ 首先你编译时，就可以采用一些小工具对字节码加密，或者做混淆等处理
+ 然后在类加载的时候，对加密的类，考虑采用自定义的类加载器来解密文件即可，这样就可以保证你的源代码不被人

# JVM类加载机制

## JVM什么情况下会加载一个类

在你的代码用到这个类的时候

```java
public class Application{
    public static void main(String[] args){
        B b=new B();
    }
}
```

假设Application类中的main方法是JVM进程启动就运行的，首先需要将Application.class加载到内存中，然后才从main方法入口执行，此时我们需要new B对象，因此我们还需要从B.class字节码文件加载对应的类到内存中来，这样代码才能跑起来

## 类加载过程

一个类从加载到使用经历的过程：加载 -> 验证 -> 准备 -> 解析 -> 初始化  -> 使用  -> 卸载

### 验证

根据Java虚拟机规范，校验我们加载进来的".class"文件中的内容，是否合乎规范

### 准备

```java
public class B{
    private static int value;
}
```

+ 给B类分配一定的空间
+ 给类变量分配一定的空间，并设置默认的初始值

### 解析（TO）

**将符号引用替换为直接引用**

### 初始化

+ 初始化静态变量
+ 执行静态代码块

**什么时候会初始化一个类？**

> 疑惑

## 类加载器和双亲委派机制

### 类加载器器

