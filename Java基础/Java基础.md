# Java基础

## 面向对象

### 什么是面向过程（Java）

### 核心要素

+ 数据结构：原生类型、对象类型、数组类型、集合类型
+ 方法调用：访问性、返回类型、方法参数、异常等
+ 执行流程：赋值、逻辑、迭代（循环）、递归等

### 什么是面向对象

Class -> Object

### 面向对象三大特征

+ 封装
+ 继承
+ 多态

### 面向对象设计模式

+ GoF23 : 构建、结构、行为
+ 方法设计：名称、访问性、参数、返回类型
+ 泛型设计：类级别、方法级别
+ 异常设计：层次性、传播性

#### 方法设计

+ 单元：一个类或一组类（**组件**）

  + 类采用名词结构
    + 动词过去式 + 名词
      + `ContextRefreshedEvent`
    +  动词ing + 名词
      + `InitializingBean`
    + 形容词+名词
      + `ConfigurableApplicationContext`

+ 执行：某个方法

  + 方法命名：动词

    + execute
    + fallback
    + init
    + run
    + refresh
+ 方法参数：名词
  
#### 异常设计

+ 根（顶层）异常：
  
  + `Throwable`
      + checked类型：`Exception`
         + unchecked类型: `RuntimeException`
      + 不常见: `Error`
  
  + since java1.4  `java.lang.StackTraceElement`
  
    + 添加异常原因(cause)
    
      + 反模式：吞掉某个异常
    
      + 性能：注意 `fillInStackTrace()` 方法的开销，避免异常栈调用深度
    
        + 方法一：JVM参数控制栈深度（物理屏蔽）
    
          > 一劳永逸，不用改代码
    
        + 方法二：logback日志框架控制堆栈输出深度（逻辑屏蔽）
    
  ```java
   public Throwable() {
          fillInStackTrace();
   }
   public Throwable(String message) {
          fillInStackTrace();
          detailMessage = message;
   }
  ```
  
  > 通过`fillInStackTrace()`方法可以将异常信息打出来
  
  设计系统和代码前要充分考虑性能和安全问题

#### 泛型设计（>=java5）

Java泛型属于编译时处理，运行时擦写

> 为什么要进行运行时擦写，因为运行时泛型对应的类型不确定，所以需要将泛型擦写为Object



### 面向对象五大原则

#### S( Single-Resposibility Principle ): 单一职责原则

一个类只做一件事

#### O( Open-Closed principle ):  开放封闭原则

 其核心思想是：**软件实体应该是可扩展的，而不可修改的**。也就是，对扩展开放，对修改封闭的。

开放封闭原则主要体现在两个方面

1、对扩展开放，**意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况**。

2、对修改封闭，==意味着类一旦设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改==。

> **实现开放封闭原则的核心思想就是对抽象编程，而不对具体编程，因为抽象相对稳定**。
>
> + 让类依赖于固定的抽象，所以修改就是封闭的；
> + 而通过面向对象的继承和多态机制，又可以实现对抽象类的继承，通过覆写其方法来改变固有行为，实现新的拓展方法，所以就是开放的。
> +  “需求总是变化”没有不变的软件，所以就需要用封闭开放原则来封闭变化满足需求，同时还能保持软件内部的封装体系稳定，不被需求的变化影响。 

#### Liskov替换原则（Liskov-Substitution Principle）

> 其核心思想是：==子类必须能够替换其基类。==

> 这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。 

Liskov替换原则，主要着眼于对抽象和多态建立在继承的基础上，因此只有遵循了Liskov替换原则，才能保证继承复用是可靠地。实现的方法是面向接口编程：将公共部分抽象为基类接口或抽象类，通过Extract Abstract Class，在子类中通过覆写父类的方法实现新的方式支持同样的职责。 

Liskov替换原则是关于继承机制的设计原则，==违反了Liskov替换原则就必然导致违反开放封闭原则==。 Liskov替换原则能够保证系统具有良好的拓展性，同时实现基于多态的抽象机制，能够减少代码冗余，避免运行期的类型判别。

#### 依赖倒置原则（Dependecy-Inversion Principle）

==其核心思想是：依赖于抽象。==

具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。

> 我们知道，依赖一定会存在于类与类、模块与模块之间。当两个模块之间存在紧密的耦合关系时，最好的方法就是分离接口和实现：在依赖之间定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。 抽象的稳定性决定了系统的稳定性，因为抽象是不变的，依赖于抽象是面向对象设计的精髓，也是依赖倒置原则的核心。 依赖于抽象是一个通用的原则，而某些时候依赖于细节则是在所难免的，必须权衡在抽象和具体之间的取舍，方法不是一层不变的。依赖于抽象，就是对接口编程，不要对实现编程。

#### 接口隔离原则（Interface-Segregation Principle）

其核心思想是：**使用多个小的专门的接口，而不要使用一个大的总接口**。 

> 具体而言，接口隔离原则体现在：接口应该是内聚的，应该避免“胖”接口。一个类对另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染。 接口有效地将细节和抽象隔离，体现了对抽象编程的一切好处，接口隔离强调接口的单一性。而胖接口存在明显的弊端，会导致实现的类型必须完全实现接口的所有方法、属性等；而某些时候，实现类型并非需要所有的接口定义，在设计上这是“浪费”，而且在实施上这会带来潜在的问题，对胖接口的修改将导致一连串的客户端程序需要修改，有时候这是一种灾难。在这种情况下，将胖接口分解为多个特点的定制化方法，使得客户端仅仅依赖于它们的实际调用的方法，从而解除了客户端不会依赖于它们不用的方法。 分离的手段主要有以下两种：1、委托分离，通过增加一个新的类型来委托客户的请求，隔离客户和接口的直接依赖，但是会增加系统的开销。2、多重继承分离，通过接口多继承来实现客户的需求，这种方式是较好的。

以上就是5个基本的面向对象设计原则，它们就像面向对象程序设计中的金科玉律，遵守它们可以使我们的代码更加鲜活，易于复用，易于拓展，灵活优雅。不同的设计模式对应不同的需求，而设计原则则代表永恒的灵魂，需要在实践中时时刻刻地遵守。就如ARTHUR J.RIEL在那边《OOD启示录》中所说的：“你并不必严格遵守这些原则，违背它们也不会被处以宗教刑罚。但你应当把这些原则看做警铃，若违背了其中的一条，那么警铃就会响起。”

### TODO 《**OOD启思录**》

## Java函数式编程

### Java函数式基础

#### 面向函数编程（Since Java 8 ）

+ Lambda表达式
+ 默认方法
+ 方法引用

#### 匿名内置类

通俗理解：没有名称的内部类

Java8以前

+ 使用场景：

  > Java 作为⼀⻔⾯向对象的**静态语⾔**，其封装性能够**屏蔽数据结构的细节**，从⽽更加关注模块的功能
  > 性。其静态性也确保了 Java 强类型的特性。随着模块功能的提升，伴随⽽来的是复杂度的增加，代
  > 码的语义清晰依赖于开发⼈员抽象和命名类或⽅法的能⼒。尽管编程思想和设计模式能够促使编程
  > ⻛格趋于统⼀，然⽽⼤多数业务系统属于⾯向过程的⽅式，这与⾯向对象编程在⼀定程度上存在⼀
  > 些冲突。Java 编程语⾔为了解决这个问题，引⼊了匿名内置类的⽅案。

  + Java是面向对象的，但不是完全面向对象，因为Java存在原生类型
  + Java是静态语言，编译成字节码后执行
  + Java的封装性能屏蔽数据结构的细节

+ 典型场景

  + Java Event/Listener

  + Java Concurent

  + Spring Template

    ```java
    JdbcTemplate.query(sql,new RowMapper(){
     ...
    })
    ```

+  基本特性

  + 无名称类

  + 声明位置

    + static block 

      ```java
      static{
         ... 
      }
      ```

    + 实例block

      ```java
      {
          ...
      }
      ```

    + 方法

      + 类方法
      + 实例方法

    + 构造器

  + 并非特殊的类结构

    + 类名称：${package}  .${declared_Class}.${num}.class

  + 基于多态，多数基于接口编程

  + 允许多个抽象方法

+ 编程局限

  + 代码臃肿
  + 强类型约束
  + 接口方法升级，匿名内部类也需要升级

#### Lambda表达式

+ 基本特点

  + 流程编排清晰
  + 函数类型编程（非强类型）
  + 改善代码臃肿
  + 兼容接口升级

+ 实现方式

  + `@FunctionalInterface`接口
  + Lambda语法
  + 方法引用
  + 接口default方法实现

+ 编程局限

  + 单一抽象方法
  + Lambda调试困难
  + Stream API操作有限

  ```java
      @FunctionalInterface
      public interface Action {
          void execute();
      }
  
      public static void main(String[] args) {
          Action action = () -> {
              System.out.println("Hello World!");
          };
          // 匿名内置类写法
          PropertyChangeListener listener = new PropertyChangeListener() {
              @Override
              public void propertyChange(PropertyChangeEvent evt) {
                  print(evt);
              }
          };
          // Lambda表达式传统写法
          PropertyChangeListener listener1 = (event) -> {
              print(event);
          };
          // Lambda 简略写法
          PropertyChangeListener listener2 = LambdaDemo::print;
      }
  
      private static void print(Object object) {
          System.out.println(object.toString());
      }
  ```

#### 总结

1. 所有的函数式接口都引用一段执行代码
2. 函数式接口没有固定的类型，固定模式（ SCFP = Supplier + Consumer + Function + Predicate） + Action
3. 利用方法引用来实现模式匹配



## 基础知识

### 位运算

#### 移位运算

+ 左移  <<

  > 操作符为<<，向左移动，右边的低位补0，高位的就舍弃掉了，将二进制看作整数，左移1位就相当于乘以2。

+ 有符号右移  >>

  > 操作符为>>，向石移动，右边的舍弃掉，**左边补什么取决于原来最高位是什么，原来是1就补1，原来是0就补0**，将二进制看作整数，右移1位相当于除以2。

+ 无符号右移  >>>

  > 操作符为>>>，向右移动，右边的舍弃掉，左边补0。

  ```java
     int a = 4; // 100
     int b = a << 2; // 左移2位就是1   10000
     int c = a >> 2; // 右移2位 001
     //  a左移两位：16
     // a右移两位：1
     System.out.println("a左移两位：" + b);
     System.out.println("a右移两位：" + c);
  ```

#### 逻辑运算

+ 按位与&：两位都为1才为1。
+ 按位或 |：只要有一位为1，就为1。
+ 按位取反~：1变为0，0变为1。
+ 按位异或^：相异为真，相同为假。

### this和super

+ this表示当前实例对象的引用，可以作为方法参数、方法的返回值
+ super只是一个关键字，用于告诉编译器访问父类的相关变量和方法，不能作为方法参数和返回值

### 构造器

Java编译器会帮类自动创建一个无参的默认构造方法，但是如果你创建了一个有参的构造方法，那么编译器将忽略创建构造方法的行为，它会认为你不需要使用无参的默认构造方法所以不会帮你创建。

### 继承

继承产生了基类与派生类，派生类继承基类，拥有基类非私有的方法和属性，但继承同时带来一个问题，派生类智能无脑无理由地继承基类的全部可继承属性和方法，没得选。

在Java中有些约定的继承

+ 每个类都会继承`Object`类
+ 枚举继承`java.lang.Enum`类
+ 注解继承`java.lang.Annotation`类

> 需要纠正的一个常识：反射是Java 5以前就有的，JDK动态代理也是的。

#### 构造器的继承

子类可以通过super来显式调用父类的构造方法

+ 如果子类没有通过super显式调用，那么会自动调用父类的默认构造方法
+ 如果父类没有默认构造方法，编译器会提示错误

### 重写与重载

重载：方法名称不同，参数个数、类型或顺序不同

重写：子类覆写父类的方法；重写时不能降低方法的访问性，因为子类是父类的代表，通过子类可以做父类的几乎所有事情，降低了重写方法的访问级别，就是降低了父类的功能

> 重载发生在编译时，重写发生在运行时（多态的体现）

### 基本数据类型

+ byte (8)
+ char(16)  本质上就是个整数
+ short(16)
+ int(32)
+ long(64)
+ float(32)
+ double(64)
+ boolean

### 方法访问性

+ public : all
+ protected : 继承 + 同包
+ (default) : 同包
+ private : 私有只给当前类访问，不给外界访问

### 浅拷贝与深拷贝

+ 深浅针对对象类型

+ 浅拷贝指的对象还是原有对象中的对象，而没有生成新的对象

+ 深拷贝产生的对象中包含的属性对象是新生成的

+ clone的代价要比new 要小

### ==内部类的原理==TODO

### 线程安全的前提

**讨论线程安全的前提是有无读写并存的场景**，如果是只读场景必然是线程安全的

### final类是不是不能有抽象方法

不是的，枚举本质上是final类，但是可以有抽象方法；但是枚举定义的抽象方法需要枚举成员去实现抽象方法。

### ==序列化与反序列化的作用== TODO

### 什么是字节码提升

字节码提升是通过字节码操作，**修改类的定义**，达到辅助类一些操作（AOP）

### ==泛型通配符的理解== TODO

`List<? extends Number> producer, List<? super Number> consumer`

extends  和super 分别有什么含义，分别在什么场景下使用

**refer to Effective Java** 

> **PECS stands for producer-extends, consumer-super**
>
> + 读取数据（生产者）使用 extends
> + 操作输出（消费者）使用 super

### Arrays.asList有猫腻

返回的ArrayList返回的是Arrays类中的内部类，不支持add操作，但可以通过set方法调整集合中的元素

### ==HashMap中红黑树的原理TODO==

### Java如何实现平台无关性

#### 什么是平台无关性

Write Once , Run Anywhere!

一种计算机语言在计算机上运行不受平台限制，一次编译到处运行

#### 实现平台无关性

.java源文件  —> .class 字节码文件  -> JVM去执行字节码文件

+ Java的平台无关性通过JVM来实现的，JVM屏蔽了底层操作系统和硬件的差异
+ Java语言规范，规范了Java语言中基本数据类型的取值范围和行为
  + 在Java中，int固定为4个字节，任意操作系统上都是这样的（这一点不同于C++）