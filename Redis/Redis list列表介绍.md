[toc]

# 列表

**列表（list）类型是用来存储多个有序的字符串，列表中的每个字符串 称为元素（element），一个列表最多可以存储232-1个元素。**

> 在Redis中，可以对列表两端插入（push）和弹出（pop），还可以获取指定范围的元素列表、获取指定索引下标的元素等。列表是一种比 较灵活的数据结构，它可以充当栈和队列的角色，在实际开发上有很多应用 场景。

## 列表的特点

1. 列表是有序的，可以通过下标来获取某个元素或者某个范围内的多个元素
2. 列表中的元素是可以重复的（基本特点）

## 内部编码

### `ziplist`（压缩列表）

当列表的元素个数小于`list-max-ziplist-entries`配置（默认512个），同时列表中每个元素的值都小于`list-max-ziplistvalue`配置时（默认64字节），Redis会选用`ziplist`来作为列表的内部实现来减少内存的使用。

### `linkedlist`（链表）

当列表类型无法满足`ziplist`的条件时，Redis会使用 `linkedlist`作为列表的内部实现。 

### 总结

> Redis3.2版本提供了`quicklist`内部编码，简单地说它是以一个`ziplist`为节点的`linkedlist`，它结合了`ziplist`和`linkedlist`两者的优势，为列表类型提供了一种更为优秀的内部编码实现，它的设计原理可以参考Redis的另一个作者https://matt.sh/redis-quicklist的博客

以上内容来自于《Redis开发与运维》

## 使用场景

1. 消息队列

   > Redis的`lpush`+`brpop`命令组合即可实现**阻塞队列**，生产者客户端使用`lrpush`从列表左侧插入元素，多个消费者客户端使用`brpop`命令 阻塞式的“抢”列表尾部的元素，多个客户端保证了消费的负载均衡和高可用性。
   >
   > **生产上个人觉得这种方案不可以作为消息队列来使用**
   >
   > + 不能保证不丢失消息
   > + 不方便维护和管理 没有监控的管理后台页面
   > + 丢失消息无法定位故障原因
   > + Redis的高可用方案不太合适
   > + 单线程机制  并发量过高时性能会大大下降
   > + 消费者如何更有效的消费消息？  可以做到分批次消费吗
   >
   > 以上只是个人理解

> 1. lpush+lpop=Stack（栈）
> 2. lpush+rpop=Queue（队列）
> 3. lpsh + ltrim  = Capped Collection（有限集合）
> 4. lpush+brpop=Message Queue（消息队列）