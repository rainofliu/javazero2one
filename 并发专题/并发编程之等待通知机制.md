[toc]

# 等待通知机制

1. 如果线程要求的条件不满足，则线程阻塞自己，进入等待状态；

2. 当线程要求的条件满足后，通知等待的线程重新执行。

   > 其中，使用线程阻塞的方式就能避免循环等待消耗 CPU 的问题。

   **阻塞是由自己发起的，通知是其他人发起的。**

## Java语言是如何支持等待--通知机制的

**一个完整的等待 - 通知机制**：线程首先获取互斥锁，当线程要求的条件不满足时，释放互斥锁，进入等待状态；当要求的条件满足时，通知等待的线程，重新获取互斥锁。

### 用 `synchronized` 实现等待 - 通知机制

在 Java 语言里，等待 - 通知机制可以有多种实现方式，比如 Java 语言内置的 `synchronized` 配合 `wait()`、`notify()`、`notifyAll()` 这三个方法就能轻松实现。

# 总结

**等待 - 通知机制是一种非常普遍的线程间协作**的方式。工作中经常看到有同学使用轮询的方式来等待某个状态，其实很多情况下都可以用今天我们介绍的等待 - 通知机制来优化。

Java 语言内置的 synchronized 配合 wait()、notify()、notifyAll() 这三个方法可以快速实现这种机制，但是它们的使用看上去还是有点复杂，所以你需要认真理解等待队列和 wait()、notify()、notifyAll() 的关系。**最好用现实世界做个类比，这样有助于你的理解。**

> 尽量使用 `notifyAll()`来唤醒等待的线程（阻塞状态: Timed–Waiting、Waiting)

# 优秀的评论区

> wait()方法与sleep()方法的不同之处在于，wait()方法会释放对象的“锁标志”。当调用某一对象的wait()方法后，会使当前线程暂停执行，并将当前线程放入**对象等待池**中，直到调用了notify()方法后，将从对象等待池中移出任意一个线程并放入锁标志等待池中，只有锁标志等待池中的线程可以获取锁标志，它们随时准备争夺锁的拥有权。当调用了某个对象的notifyAll()方法，会将对象等待池中的所有线程都移动到该对象的**锁标志等待池。**
> sleep()方法需要指定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态，该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。但是**sleep()方法不会释放“锁标志”**，也就是说如果有synchronized同步块，其他线程仍然不能访问共享数据。



> wait和sleep区别
> 1：wait释放资源，sleep不释放资源
> 2：wait需要被唤醒，sleep不需要
> 3：wait需要获取到监视器，否则抛异常，sleep不需要
> 4：wait是object顶级父类的方法，sleep则是Thread的方法



> 1. wait会释放所有锁而sleep不会释放锁资源.
>
> 2. wait只能在同步方法和同步块中使用，而sleep任何地方都可以.
>
> 3. wait()无参数需要唤醒，线程状态WAITING；wait(1000L);到时间自己醒过来或者到时间之前被其他线程唤醒，状态和sleep都是TIME_WAITING
>
>   两者相同点：都会让出CPU执行时间，等待再次调度！



