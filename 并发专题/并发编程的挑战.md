[toc]

# 并发编程的挑战

**并发编程的目的是为了让程序运行得更快，但是，并不是启动更多的线程就能让程序最大限度地并发执行**。在进行并发编程时，如果希望通过多线程执行任务让程序运行得更快，会面临非常多的挑战，比如上下文切换的问题、死锁的问题，以及受限于硬件和软件的资源限制问题。

> 创建线程也耗费时间

## 线程上下文切换

即使是单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现 这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切 换线程执行，让我们感觉多个线程是同时执行的，时间片一般是几十毫秒（ms）。 

CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个 任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这 个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。

> 线程上下文切换起因： CPU时间片分配算法
>
> 线程上下文切换会影响多线程的执行速度。

### 减少线程上下文切换

因为线程上下文切换会影响多线程执行效率，所以我们需要减少上下文切换，那么有哪些方法呢？

1. 无锁并发编程

   > 多线程竞争锁，会引起**线程上下文切换 **？？？

2. CAS算法

3. 使用最少线程

   > 避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这 
   >
   > 样会造成大量线程都处于等待状态

4. 使用协程

   > 在单线程内实现多任务的调度，并在单线程中维持多个任务间的切换

## 死锁

避免死锁：

1. 避免一个线程同时获取多个锁。
2. 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。
3. 尝试使用定时锁，使用`lock#tryLock（timeout）`来替代使用内部锁机制。
4. 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。