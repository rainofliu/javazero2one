[toc]

# 互斥锁

一个或者多个操作在 CPU 执行的过程中不被中断的特性，称为“**原子性**”。

## 原子性如何解决

**原子性问题的源头是线程切换**，如果能够禁用线程切换那不就能解决这个问题了吗？

> 而**操作系统做线程切换是依赖 CPU 中断的**，所以禁止 CPU 发生中断就能够禁止线程切换。



我们以 32 位 CPU 上执行 long 型变量的写操作为例来说明这个问题，long 型变量是 64 位，在 32 位 CPU 上执行写操作会被拆分成两次写操作（写高 32 位和写低 32 位）

> **在单核 CPU 场景下，同一时刻只有一个线程执行**，禁止 CPU 中断，意味着操作系统不会重新调度线程，也就是禁止了线程切换，获得 CPU 使用权的线程就可以不间断地执行，所以两次写操作一定是：要么都被执行，要么都没有被执行，具有原子性。
>
> **但是在多核场景下，同一时刻，有可能有两个线程同时在执行**，一个线程执行在 CPU-1 上，一个线程执行在 CPU-2 上，此时禁止 CPU 中断，只能保证 CPU 上的线程连续执行，并不能保证同一时刻只有一个线程执行，如果这两个线程同时写 long 型变量高 32 位的话，那就有可能出现我们开头提及的诡异 Bug 了。



禁止线程上下文切换其实对于多核心CPU来说并不能保证原子性，因为单个CPU上线程是连续执行（不中断），但是多个CPU上加起来可能有多个线程同时执行long变量，这就bug了。



> **同一时刻只有一个线程在执行，我们称为“互斥”。**
>
> **如果我们能够保证对共享变量的修改是互斥的，那么，无论是单核 CPU 还是多核 CPU，就都能保证原子性**

### 简易锁模型

**我们把一段需要互斥执行的代码称为临界区。**

线程在进入临界区之前，首先尝试加锁 lock()，如果成功，则进入临界区，此时我们称这个线程持有锁；否则就等待，直到持有锁的线程解锁；持有锁的线程执行完临界区的代码后，执行解锁 unlock()。

### 改进后的锁

我们知道在现实世界里，**锁和锁要保护的资源是有对应关系的**，比如你用你家的锁保护你家的东西，我用我家的锁保护我家的东西。在并发编程世界里，锁和资源也应该有这个关系。

#### Java语言层面的锁`synchoronized`

```java
class X {
  // 修饰非静态方法
  synchronized void foo() {
    // 临界区
  }
  // 修饰静态方法
  synchronized static void bar() {
    // 临界区
  }
  // 修饰代码块
  Object obj = new Object()；
  void baz() {
    synchronized(obj) {
      // 临界区
    }
  }
}  
```

> Java 编译器会在 `synchronized` 修饰的方法或代码块前后自动加上加锁 lock() 和解锁 unlock()，这样做的好处就是加锁 lock() 和解锁 unlock() 一定是成对出现的

+ 当修饰静态方法的时候，锁定的是当前类的 Class 对象；
+ 当修饰非静态方法的时候，锁定的是当前实例对象 this。

#### 锁和受保护资源的关系

**受保护资源和锁之间的关联关系是 N:1 的关系**

> 我们可以使用一把锁来锁住多个受保护资源。

## 总结

互斥锁，在并发领域的知名度极高，只要有了并发问题，大家首先容易想到的就是加锁，因为大家都知道，加锁能够保证执行临界区代码的互斥性。这样理解虽然正确，但是却不能够指导你真正用好互斥锁。

临界区的代码是操作受保护资源的路径，类似于球场的入口，入口一定要检票，也就是要加锁，但不是随便一把锁都能有效。所以必须**深入分析锁定的对象和受保护资源的关系**，综合考虑受保护资源的访问路径，多方面考量才能用好互斥锁。

`synchronized` 是 Java 在语言层面提供的互斥原语，其实 Java 里面还有很多其他类型的锁，但作为互斥锁，原理都是相通的：**锁，一定有一个要锁定的对象，至于这个锁定的对象要保护的资源以及在哪里加锁 / 解锁，就属于设计层面的事情了**。

**锁给某个对象枷锁，然后这个对象保护了一些资源**

## 如何用一把锁锁住多个资源

1. 保护没有关联关系的多个资源，正常枷锁

2. 保护有关联关系的多个资源

   > 增大锁的粒度

### 总结

如果资源之间没有关系，很好处理，每个资源一把锁就可以了。

> 如果资源之间有关联关系，就要选择一个粒度更大的锁，这个锁应该能够覆盖所有相关的资源



**“原子性”的本质是什么？其实不是不可分割，不可分割只是外在表现，其本质是多个资源间有一致性的要求**，操作的中间状态对外不可见。例如，在 32 位的机器上写 long 型变量有中间状态（只写了 64 位中的 32 位），在银行转账的操作中也有中间状态（账户 A 减少了 100，账户 B 还没来得及发生变化）。所以解决原子性问题，是要保证中间状态对外不可见。

> **中间状态对其他线程不可见，因为线程切换不可避免，在共享资源保障原子性的条件下，切换成其他线程，其他线程也不可以操作此共享资源**



**不可以使用可变对象作为锁定对象。**