[toc]

本文梳理一下并发编程的主要知识点以及学习攻略。

# 学习并发编程的必要性

并发慢慢成为一项必备技能。

Java 里 synchronized、wait()/notify() 相关的知识很琐碎，看懂难，会用更难。但实际上 synchronized、wait()、notify() 不过是操作系统领域里管程模型的一种实现而已，Java SDK 并发包里的条件变量 Condition 也是管程里的概念，synchronized、wait()/notify()、条件变量这些知识如果单独理解，自然是管中窥豹。但是如果站在管程这个理论模型的高度，你就会发现这些知识原来这么简单，同时用起来也就得心应手了。

> 管程作为一种解决并发问题的模型，是继信号量模型之后的一项重大创新，它与信号量在逻辑上是等价的（可以用管程实现信号量，也可以用信号量实现管程），但是相比之下管程更易用。而且，很多编程语言都支持管程，搞懂管程，对学习其他很多语言的并发编程有很大帮助。然而，很多人急于学习 Java 并发编程技术，却忽略了技术背后的理论和模型，而理论和模型却往往比具体的技术更为重要。

**其实并发编程可以总结为三个核心问题：分工、同步、互斥。**

**所谓分工指的是如何高效地拆解任务并分配给线程，而同步指的是线程之间如何协作，互斥则是保证同一时刻只允许一个线程访问共享资源。**Java SDK 并发包很大部分内容都是按照这三个维度组织的，例如 Fork/Join 框架就是一种分工模式，CountDownLatch 就是一种典型的同步方式，而可重入锁则是一种互斥手段。当把并发编程核心的问题搞清楚，再回过头来看 Java SDK 并发包，你会感觉豁然开朗，它不过是针对并发问题开发出来的工具而已，此时的 SDK 并发包可以任你“盘”了。而且，这三个核心问题是跨语言的，你如果要学习其他语言的并发编程类库，完全可以顺着这三个问题按图索骥。Java SDK 并发包其余的一部分则是并发容器和原子类，这些比较容易理解，属于辅助工具，其他语言里基本都能找到对应的。

> 并发编程并不是 Java 特有的语言特性，它是一个通用且早已成熟的领域。Java 只是根据自身情况做了实现罢了，当你理解或学习并发编程的时候，如果能够站在较高层面，系统且有体系地思考问题，那就会容易很多。



# 如何学好并发编程

> 并发编程并不是一门相对独立的学科，而是一个综合学科。并发编程相关的概念和技术看上非常零散，相关度也很低，总给你一种这样的感觉：我已经学习很多相关技术了，可还是搞不定并发编程。那如何才能学习好并发编程呢？

## 跳出来，看全景

建立一张并发编程的全景图。

**并发编程领域可以抽象成三个核心问题：分工、同步和互斥**

### 分工

所谓分工，类似于现实中一个组织完成一个项目，项目经理要拆分任务，安排合适的成员去完成。

> 分工是安排不同的线程做不同的事情，是一个任务的安排行为。

分工很重要也很复杂，Java并发编程的分工主要有：

1. 并发包（分工）

   1. `Executor`

      > 线程池

   2. `Fork/Join`

   3. `Future`

2. 分工的设计模式

   1. 生产者、消费者问题

      > 类比现实世界：餐馆里的大厨和服务员，大厨就是生产者，负责做菜，做完放到出菜口，而服务员就是消费者，把做好的菜给你端过来。
      >
      > 我们经常会发现，出菜口有时候一下子出了好几个菜，服务员是可以把这一批菜同时端给你的。其实这就是生产者 - 消费者模式的一个优点，**生产者一个一个地生产数据，而消费者可以批处理**，这样就提高了性能**（优化）**

   2. `Thread-Per-Message`

   3. `Worker Thread `

### 同步

分好工以后，就是具体执行任务了。

> 在项目执行过程中，任务之间是有依赖的，一个任务结束后，依赖它的后续任务就可以开工了，后续工作怎么知道可以开工了呢？这个就是靠**沟通协作**了，这是一项很重要的工作。
>
> 线程之间该如何沟通协作呢？
>
> 同步讲的是安排好分工后的执行阶段

**在并发编程领域里的同步，主要指的就是线程间的协作**，本质上和现实生活中的协作没区别，不过是**一个线程执行完了一个任务，如何通知执行后续任务的线程开工而已**。

协作一般是和分工相关的。Java SDK 并发包里的 `Executor`、`Fork/Join`、`Future` 本质上都是分工方法，**但同时也能解决线程协作的问题。**

例如，用 Future 可以发起一个异步调用，当主线程通过 get() 方法取结果时，主线程就会等待，当异步执行的结果返回时，get() 方法就自动返回了。主线程和异步线程之间的协作，Future 工具类已经帮我们解决了。

> 除此之外，Java SDK 里提供的 CountDownLatch、CyclicBarrier、Phaser、Exchanger 也都是用来解决线程协作问题的。

工作中遇到的线程协作问题，基本上都可以描述为这样的一个问题：**当某个条件不满足时，线程需要等待，当某个条件满足时，线程需要被唤醒执行**。例如，在生产者 - 消费者模型里，也有类似的描述，“**当队列满时，生产者线程等待，当队列不满时，生产者线程需要被唤醒执行；当队列空时，消费者线程等待，当队列不空时，消费者线程需要被唤醒执行。**”

> 在 Java 并发编程领域，**解决协作问题的核心技术是管程**，上面提到的所有线程协作技术底层都是利用管程解决的。**管程是一种解决并发问题的通用模型**，除了能解决线程协作问题，还能解决互斥问题。可以这么说，**管程是解决并发问题的万能钥匙。**

+ 理解**管程模型**是学好线程协作的基石

  > 底层原理

+ 再去 Java SDK 并发包提供的几个**线程协作的工具类**的应用场景

  > 实践层面，提高工作效率

### 排斥

分工、同步主要强调的是**性能**，但并发程序里还有一部分是关于正确性的，用专业术语叫**“线程安全”**。

并发程序里，当多个线程同时访问同一个共享变量的时候，结果是不确定的。不确定，则意味着可能正确，也可能错误，事先是不知道的。

而导致不确定的主要源头是**可见性问题、有序性问题和原子性问题**，为了解决这三个问题**，Java 语言引入了内存模型**，内存模型提供了一系列的规则，利用这些规则，我们可以**避免可见性问题、有序性问题**，但是还不足以完全解决线程安全问题。

可见性、有序性和原子性问题引出了 Java内存模型（解决前面的问题）

> **解决线程安全问题的核心方案还是互斥。（原子性）**

**互斥**：指同一时刻，只有一个线程访问共享变量

实现互斥的核心技术是锁。

（加锁可以保证线程安全，但是带来了性能开销）

+ 优化锁的性能

  > 根据不同的场景作不同的优化，没有万金油！

+ 使用无锁操作来保证线程安全

> Java 语言里 `synchronized`、SDK 里的各种 `Lock` 都能解决互斥问题。
>
> **虽说锁解决了安全性问题，但同时也带来了性能问题**，那如何保证安全性的同时又尽量提高性能呢？
>
> + 可以分**场景优化**，Java SDK 里提供的 `ReadWriteLock`、`StampedLock` 就可以优化**读多写少**场景下锁的性能。
>
> + 还可以使用无锁的数据结构，例如 Java SDK 里提供的**原子类**都是基于无锁技术实现的。
> + 除此之外，还有一些其他的方案，原理是不共享变量或者变量只允许读。这方面，Java 提供了 `Thread Local` 和 `final` 关键字，还有一种 Copy-on-write 的模式

使用锁还需要考虑死锁问题

> 这部分内容比较复杂，往往还是跨领域的，例如要理解可见性，就需要了解一些 CPU 和缓存的知识；要理解原子性，就需要理解一些操作系统的知识；很多无锁算法的实现往往也需要理解 CPU 缓存。这部分内容的学习，需要博览群书，在大脑里建立起 CPU、内存、I/O 执行的模拟器。

![](https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/并发编程全景图（王宝令）.png)

## 钻进去，看本质

但是光跳出来还不够，还需要下一步，就是在某个问题上钻进去，深入理解，找到本质。

Java 语言里的并发技术基本都是有理论基础的，并且这些理论在其他编程语言里也有类似的实现。

> 技术的本质是背后的理论模型。

## 总结

1. **要让自己的知识成体系**，一定要挖掘 Java SDK 并发包背后的**设计理念**。Java SDK 并发包是并发大师 Doug Lea 设计的，他一定不是随意设计的，一定是深思熟虑的，其背后是 Doug Lea 对并发问题的深刻认识。可惜这个设计的思想目前并没有相关的论文，所以只能自己琢磨了。
2. 对于某个具体的技术，我建议你**探索它背后的理论本质**，理论的应用面更宽，一项优秀的理论往往在多个语言中都有体现，在多个不同领域都有应用。所以探求理论本质，既能加深对技术本身的理解，也能拓展知识深度和广度，这是个一举多得的方法。这方面，希望我们一起探讨，共同进步。