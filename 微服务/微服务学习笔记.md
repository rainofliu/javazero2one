[toc]

# 微服务的介绍

## 什么是微服务架构

+ 微服务（MicroService）

  > 微服务架构是一种流行的架构设计风格，通常用作单体(Monolith)应用的替代方案

## 单体应用的问题

**单体应用的本质其实就是不能满足细粒度的需求，就是对某个模块单独扩展，某个模块更改 不能影响到其他模块的正常功能，某个模块要能快速上线，要能够独立部署，而微服务架构就是这样一个独立模块自治自由的架构实现。**

1. 单体应用过于复杂，超过了单个开发人员的理解能力

2. 缓慢的开发速度

   > + 一个小小的改动，都需要对系统整体模块进行测试，**牵一发而动全身**的体验
   > + 其次，因为整个应用打成一个包部署，部署上线方式也不够自动化与智能

3. 应用比较难进行扩展

   + 垂直扩展

     > + 垂直扩展就是对单台机器进行扩展
     >
     > + 单体应用所有模块都在一起，A模块对CPU要求高，B模块对IO要求高，就导致垂直扩展不能精准化

   + 水平扩展

     > + 水平扩展就是加实例，让系统集群化
     >
     > + 水平扩展固然可以优化单体应用的性能，但是如果A模块不需要扩展，单实例就可以满足性能要求，而B模块需要3个实例组成集群就可以达到好的性能，而C模块。。。，其实系统的水平扩展还是不能精准化

4. 新版本更新上线速度慢

   因为首先单体应用作为一个整体，我们开发人员提交了代码到版本控制系统中，需要对合并提交代码后的应用（**此时应该是测试环境中的测试应用**）手动或自动测试，这个过程比较漫长。

   > 单体应用太大了

5. 整体应用的稳定性较差

   + 引起系统宕机不能高可用的原因有很多，比如内存溢出，数据库服务器宕机

   + 某个报表或者excel导出程序占据了大量的CPU，内存以及数据库连接资源，都会对整个系统的性能和稳定产生影响

     就算集群化也不能彻底解决稳定性问题

6. 技术栈的更新和选型比较困难

   + 技术栈包含编程语言，框架，第三方库以及数据库和消息中间件等

   + 比如说我单体应用使用Java开发，那整个应用稳定线上运行期间，都智能使用Java语言；

   + 数据库连接池如果要换，对整体应用都需要做很大的改动，然后还要担心性能和稳定性，整个系统会不会出新的bug

   **就是很畏手畏脚的更新技术**

   > 还有一点，数据库只能选择固定的存储方式，其实有的数据适合Redis存储，有的适合mongodb存储

## 微服务架构的特征

> **In short, the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.** 

上面是 [Martin Fowler](https://martinfowler.com/) 大叔对微服务架构风格的描述，简单概括如下：

+ 将原有单体应用拆分成多个小的服务
+ 每个服务作为单独一个进程存在，服务与服务之间通过轻量级的方法通信，比如HTTP
+ 每个服务可独立部署，并且是采用自动化的部署方式
+ 对于这些服务要去中心化管理，让其自治，并且每个服务可以采用不同的编程语言和不同的数据存储技术

下面对上述简述作进一步说明

### 微服务架构使用服务作为组件化的单元

+ 在微服务架构中，组件的单元变成了服务
+ 服务运行在独立的进程，需要类似HTTP这样的进程通信方式
+ 每个服务可独立部署，需要对其他服务暴露API接口
+ 服务与服务之间只能通过API访问另外的服务，并不能访问其内部代码和数据存储中心

### 微服务架构的开发团队围绕业务能力来组织

+ 单体应用的开发团队按照**技能**来划分，一般分为前端开发，后端开发和数据库管理等

+ 微服务架构的开发团队以**服务为单元来组织**，每个服务与特定的业务需求相对应

  > 微服务的开发团队包含开发、测试和DevOps相关的全部人员
  >
  > 某个微服务的开发团队人员较少，小团队沟通成本更低，开发效率相对来说更高

### 微服务使用去中心化的管理模式

+ 微服务架构中的服务可独立部署，可采用不同的技术栈开发

+ 每个团队自主管理所负责的服务，不但负责构建，还同样负责运行和维护，这样提高了团队的自主性和主观能动性，降低了管理的成本

### 微服务采用去中心的数据存储

微服务可以采取最适合自己的数据存储方式，有更多的选择自由

### 微服务强调基础设施自动化

+ 微服务应用可独立部署，所以服务实例较多时，需要自动化部署
+ 持续集成和持续部署都是微服务通用的实践

### 微服务架构在设计时充分考虑到失败的情况

微服务之间的交互通过进程间通信来完成，所以要考虑交互失败的情况

## 微服务架构的问题

### 最大的问题：微服务本身实现的复杂性

使用微服务架构后，系统整体变成了一个分布式系统，分布式系统是特别复杂的

### 如何划分微服务

### 数据的一致性

**服务可能使用不同的数据存储（关系型数据库和No SQL数据库），在不同的数据存储中，如何保证数据的一致性**

+ 在单体应用中可以通过ACID保证数据的一致性
+ 在微服务架构中，通常保证的是数据**最终一致性**

### 微服务架构对运维提出了更高的要求

### 微服务面临的挑战

+ 注册与发现

  > 为什么需要注册中心，因为服务实例是动态变化的，而不是固定不变的。

+ 路由

+ 可靠性

  > 进程内的调用除非进程终止了，否则一般都是可靠的；

  > 服务之间跨进程的调用会因各种原因而不可靠

+ 延迟

  服务调用会因网络，序列化等原因而延迟

+ 热点

  负载均衡用来解决热点问题。

+ 短路

  保护服务

+ 伸缩

  > Docker容器

+ 异步

  消息只是异步的一种形式。

+ 监控

+ 配置

  分布式配置Spring Cloud Config

  > **配置文件修改后，要立即同步到应用中。**

+ 数据同步
  
+ CAP原则
  
+ 安全

+ Web前端：XSS 

+ 认证鉴权；服务之间是否有权限，第三方认证登陆

## 微服务架构的实现

![微服务架构的实现](https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/第01讲：什么是微服务架构_24.png)

## 微服务的技术选择

+ Netflix OSS

+ Spring Cloud  

  + Based on Spring Framework 
  + Spring Cloud Commons

+ Kebernetes 

  > **管理容器化工作负载和服务的平台，同时也是容器编排平台**

# Docker与容器化技术简介

微服务架构应用的本质是**分布式系统**，微服务实例很多，数据存储中间件，消息中间件等都很多，对运维也提出了更高的要求，微服务架构应用的部署离不开容器应用。

## 应用部署技术的发展

![应用部署技术的发展](https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/应用部署方式演进图.png)

### 硬件虚拟化

+ 硬件虚拟化指的是对计算机的虚拟化，虚拟化对用户隐藏了计算平台的物理特征，仅仅提供一个抽象的计算平台。

+ 用来控制虚拟化的程序称为 **Hypervisor**，它可以创建和运行虚拟机 

+ 在虚拟机上可以安装不同类型的操作系统，包括 Windows、Linux 和 MacOS 

+ **虚拟机实例共享虚拟化的硬件资源** 

总结一下：其实就是先在操作系统上安装**Hypervisor**，然后根据需要创建和运行虚拟机，在虚拟机上创建操作系统，然后在操作系统里运行应用。

**缺点：**

硬件虚拟化的不足之处在于**只能以操作系统为单位进行扩展，操作系统本身也需要资源。**

> 我的理解是 虚拟机实例中需要创建操作系统后才能运行应用程序，而操作系统也需要资源，并不是所有资源都给了我们的应用。

### 容器化技术

#### 传统部署流程的问题

早期软件开发实践，开发团队的成员在本地环境开发，然后通过持续集成环境构建出可部署的工件（Artifact）；部署的工作交给运维团队来完成，根据开发团队的文档安装应用及应用所依赖的外部服务，如数据库和消息中间件等。

> 如果开发团队的文档有误，就会导致运维团队安装的生产环境应用出现问题

这样的开发方式及其容易造成**本地开发环境和线上运行环境**的不一致，很多情况下本地是好的，线上就是有问题。

![](https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/传统部署方式.png)

#### 容器化技术的优点

容器化技术提供了一种**更简洁的方式**来描述可运行的应用。

我们可以不用给运维团队提供参数，将参数直接内置在应用中，不就可以了嘛！:kissing_smiling_eyes:这就是**镜像文件**。

![](https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/容器化部署方式.png)



**容器化最大的优势是不可变！**在进行版本更新时，如果出现没有预料到的问题，可以使用上一个版本的镜像重新运行容器，就可以实现版本快速回退。

> 容器的不变性是实现开发环境、测试环境和线上环境一致的前提
>
> 类似于多线程场景下，某个值是只读的、不会被修改，那和它相关的场景**一般情况下**应该是线程安全的。

还有一点，如果生产环境出现问题，我们可以把镜像拿到本地环境来测试。

##### 容器化解决了不同环境之间的一致性问题

开发环境产出的应用镜像，经过测试团队的测试后被部署到生产环境中

**此时开发、测试和生产环境使用的是同样的镜像。**

## Docker的基本概念

Docker中最重要的概念是**镜像**和**容器**。

+ **镜像**是创建容器的只读模板，可以从 Docker 注册表中下载，也可以创建自定义镜像 

  > Docker Hub 是默认的镜像注册表，包含了非常多可用的镜像，企业内部也可以搭建自己私有的注册表 

  > 通常创建镜像的方式：在已有的镜像上进行定制，得到新的镜像 

+ **容器**是镜像的可运行实例，从镜像中创建出来的容器，可以被启动、暂停、停止和删除

> 镜像可以比作一个程序，而容器可以比作运行时的程序，也就是进程。

## Docker的安装

+ Windows平台

  + win10专业版 可安装 Docker Desktop

  + win10家庭版 可安装 Docker Toolbox 

    > Docker Toolbox 内嵌了Git、Oracle VM VirtualBox

+ Linux  安装 Docker Engine

## ==关于Docker的操作，后续更新（TODO）==

# 云原生应用

==微服务架构实现的最大难度是复杂度==。在实现微服务架构时，开发团队需要选择能够帮助应对这些复杂性的平台和工具。

**云原生应用(Cloud Native)是微服务架构的最佳实现方式。**

## 云原生应用的概念

云原生应用的概念由**云**和**原生**组成。

+ 云

  > 云平台，平台即服务（Platform as a Service  PaaS）

+ 原生应用

  > 专门针对云平台而设计实现的，充分运用了云平台的特性

原生：

+ 原生通常意味着==高效和难以移植==
+ 原生意味着==针对特定的平台而设计的==，可以充分利用平台的特性，因此运行起来特别地高效
+ 原生意味着与特定平台的深度绑定，很难移植到其他平台

> 原生相当于定制，可以类比MyBatis 换了数据库后 SQL语句都需要修改

## 云原生应用的特征

### 单一代码库

==云原生应用必须有单一的代码库，并在版本管理系统中进行追踪。==

+ 单一代码库可以是一个代码仓库，也可以是共享同一根目录的多个代码仓库

+ 单一代码库的**重要性**：每一个代码提交(Commit) 都会对应一个**不可变的构建版本**

  > 在每次代码提交后，**持续集成**流程就会被触发，最终产生一系列的应用容器镜像。
  >
  > ==这样就在**代码提交**和**构建版本**之间建立了一对一的对应关系。==

对于微服务架构的应用来说，每个应用由多个服务组成一个整体；

**这些服务应该由单一的代码库进行管理，这就保证了构建版本的稳定性。**

+ 如果一个改动涉及到多个服务，则这个改动应该在一次提交中完成对所有相关服务的修改
+ 如果服务的代码分散在多个代码库，则一个改动会被分成多个代码提交
  + 每个代码提交都会触发一次持续集成，产生对应服务的构建版本，而这些服务的构建版本**只包含了部分改动，是不完整的**

> 微服务架构的应用应该使用单一代码库。

### API优先

云原生应用应该选用API优先的设计策略。

微服务架构的应用使用公开API作为服务的对外接口，API屏蔽了服务的内部细节（如：数据库等）。

> 同理，对于一个外部应用来说，调用分布式应用系统的网关 也是屏蔽系统内部细节的一种体现。

==API优先的设计策略是指在设计阶段，应该首先设计API并确定API的细节。==

**优点：**

+ API优先的策略保证了API的稳定性，同时也可以减少不必要的后期修改

  > API是服务之间通信的接口，修改API意味着相关的内部实现、测试用例和API的使用者都需要进行修改

+ API优先策略可以提高开发效率

  > Swagger API
  >
  > 个人觉得Swagger这样生成API文档的工具，大量重复的注解配置在Controller中，对应用代码有极大的侵入性，能否有更方便的方式实现自动配置，类似于MyBatis自动生成xml和Mapper文件的方式；也可以是Spring @Enable*模块驱动的方式
  >
  > 之所以会这么认为，是因为配置本身就很麻烦，我很懒，能不能有更简便的方式来完成配置。:kissing_smiling_eyes:是不是中了Spring Boot自动装配的毒了！

### 依赖管理

**云原生应用应该管理自己的依赖**

常见的Java构建工具Maven和Gradle都提供了依赖管理的支持。

### 设计、构建、发布和运行

![](https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/设计、构建、发布和运行.png)

#### 设计

+ 传统应用通常采用瀑布式的开发流程，瀑布式的开发流程中会分配足够的时间去设计

+ ==云原生应用一般采用敏捷软件开发流程==

  > 设计过程变成了一个迭代的过程，通常只需要针对某些新特性进行设计

#### 构建

1. 构建阶段从单一代码库中创建出带版本号的二进制工件

2. 构建过程通常是由持续集成服务器完成，每个构建都必须有唯一不变的版本号

3. 构建出来的二进制工件是**不可变的**

   > 这样保证了同一个构建版本在经过测试之后被部署的版本与测试后的版本保持一致

#### 发布

+ 把构建出来的工件推送到云平台上，得到了一个发布版本

+ 发布版本中包含与部署环境相关的配置信息

> 云原生应用在部署时，通常有开发、测试和生产三个环境
>
> 发布版本有**唯一的发布号**
>
> ==每个构建版本都可能对应得到多个发布版本==

#### 运行

运行阶段在云平台上运行应用，运行的方式取决于云平台，可以为虚拟机或者容器

云平台负责管理应用的**运行**，包括**监控**应用运行状态，处理失败的情况或者水平扩展等

### 代码、配置和凭据

代码、配置和凭据是云原生应用**开发过程中创建的三种类型实体**。

> 这三者只和 开发有关

+ 代码    ： 包括源代码和相关资源文件

+ 配置    ： 与部署环境相关的配置信息，通常以XML 、YAML、JSON或属性文件的方式出现

  > 配置中包含的信息 包括第三方的服务连接方式、数据库连接信息和应用自身配置信息等

+ 凭据    :    密码、私钥和API秘钥等敏感信息

==代码和配置的区别在于，代码不会随着部署环境而变化，而配置会==

+ 在实践中，应该尽可能把配置从应用中分离出来，进行外部化管理

  > 根据代码构建出来的二进制工件（持续集成阶段）中不包含任何配置信息，实际的配置值在部署时根据环境来确定
  >
  > 我们可以通过`spring.profiles.active=dev` 来认识配置根据环境来确定的理论

+ 在运行时一般使用环境变量来传递配置值，也可以使用Spring Cloud Config等分布式配置中心来管理配置值

**凭据这些敏感信息应该从源代码仓库删除，for safety**

### 日志

云原生应用并不需要对日志输出方式进行很多配置，只是简单地把日志输出到**标准输出流(stdout)和标准错误流(stderr)**。

日志的收集和处理由云平台的其他服务来提供

常用的开源实现：

+ Elastic技术栈(ElasticSearch + Logstash + Kibana)
+ Fluentd

### 随时可丢弃

云原生应用的生命周期可能是短暂的，随时可能被停止

云平台可能会随时启动和停止应用的实例，这就要求云原生应用的启动和停止速度都要比较快

+ 当应用的负载突然增大时，可以快速启动新的实例来处理请求
+ 当应用的实例出现问题时，可以快速启动一个新的实例代替它

快速停止应用保证了资源可以被及时释放

### 支撑服务

支撑服务包含数据库、消息中间件、缓存、用户认证与授权，存储等等。

连接这些支撑服务的配置信息应该被抽离出来，在运行时根据部署环境提供实际值

### 环境等同

==云原生应用的不同部署环境应该是等同的。==

### 管理任务

云原生应用运行中可能需要执行一些管理任务，比如生成报表；这些任务在运行中会用到云原生应用所依赖的支撑服务，对于这些任务应该创建独立的应用，并在同样的云平台上运行

#### 生成报表

![](https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/生成报表.png)

### 端口绑定

云原生应用在运行时并不负责管理实际的端口绑定，而是由**云平台统一管理**

> 比如，一个基于Spring Boot的微服务应用通常在8080端口运行HTTP服务，当应用运行在云平台上时，这个端口只是虚拟机或容器内的端口
> ，并不是外部用户或其他服务访问时的实际端口

+ 云平台对网络进行统一管理，负责分配实际的端口
+ 云平台同时提供了相应的机制来发现访问服务的实际地址和端口

### 无状态进程

云原生应用应该是无状态的。

所有的状态信息都应该从应用中抽离出来，并保存在支撑服务中，比如数据库中。正因为应用是无状态的，才可以由云平台快速的启动和停止，并进行垂直或水平扩展。

### 并发性

云原生应用使用**水平扩展**来并发运行多个实例，使用负载均衡来把请求分配到某个实例进行处理。

### 遥测数据

云原生应用需要收集一系列遥测数据，包括应用性能指标、运行状态和日志等，这些遥测数据
云平台可以用性能指标来进行自动水平扩展，比如，Kubernetes支持Pod的自动水平扩展
当CPU的利用率超过预定的阈值时，会自动启动新的Pod来处理请求

性能指标分成两类：

+ ==业务无关的==，比如请求的数量、请求的处理速度、以及平均的请求处理时间等

+ ==业务相关的==，需要应用根据业务需求进行收集，比如处理的订单数量和不同商品的销售情况等

> 云原生应用通常会创建**仪表盘**来实时展示整体的运行状态，方便运维人员进行监控

### 认证与授权

云原生应用应该是安全的，安全应该在应用的设计阶段就充分考虑。在实现中，可以使用基于角色的访问控制（RBAC）来保护API，已经有大量的开源框架来帮助实现认证和授权。

## 总结

云原生的15个特征，有些容易实现，有些比较难实现。实际开发过程中，我们应该让自己的云原生应用尽可能满足这些特征，但也不一定要全部满足。这15个特征就类似于Servlet规范以及其他jsr规范，面向规范编程的一种体现。

# Kubernetes容器化应用 TODO 可能需要学习一本书

## Kubernetes介绍

==Kubernetes是一个可移植、可扩展的开源平台，用来管理容器化的工作负载和服务。==

它可以促进声明式的配置和自动化。

Kubernetes是目前容器编排领域的事实标准

## Kubernetes集群

