# 微服务的介绍

## 什么是微服务架构

+ 微服务（MicroService）

  > 微服务架构是一种流行的架构设计风格，通常用作单体(Monolith)应用的替代方案

## 单体应用的问题

**单体应用的本质其实就是不能满足细粒度的需求，就是对某个模块单独扩展，某个模块更改 不能影响到其他模块的正常功能，某个模块要能快速上线，要能够独立部署，而微服务架构就是这样一个独立模块自治自由的架构实现。**

1. 单体应用过于复杂，超过了单个开发人员的理解能力

2. 缓慢的开发速度

   > + 一个小小的改动，都需要对系统整体模块进行测试，**牵一发而动全身**的体验
   > + 其次，因为整个应用打成一个包部署，部署上线方式也不够自动化与智能

3. 应用比较难进行扩展

   + 垂直扩展

     > + 垂直扩展就是对单台机器进行扩展
     >
     > + 单体应用所有模块都在一起，A模块对CPU要求高，B模块对IO要求高，就导致垂直扩展不能精准化

   + 水平扩展

     > + 水平扩展就是加实例，让系统集群化
     >
     > + 水平扩展固然可以优化单体应用的性能，但是如果A模块不需要扩展，单实例就可以满足性能要求，而B模块需要3个实例组成集群就可以达到好的性能，而C模块。。。，其实系统的水平扩展还是不能精准化

4. 新版本更新上线速度慢

   因为首先单体应用作为一个整体，我们开发人员提交了代码到版本控制系统中，需要对合并提交代码后的应用（**此时应该是测试环境中的测试应用**）手动或自动测试，这个过程比较漫长。

   > 单体应用太大了

5. 整体应用的稳定性较差

   + 引起系统宕机不能高可用的原因有很多，比如内存溢出，数据库服务器宕机

   + 某个报表或者excel导出程序占据了大量的CPU，内存以及数据库连接资源，都会对整个系统的性能和稳定产生影响

     就算集群化也不能彻底解决稳定性问题

6. 技术栈的更新和选型比较困难

   + 技术栈包含编程语言，框架，第三方库以及数据库和消息中间件等

   + 比如说我单体应用使用Java开发，那整个应用稳定线上运行期间，都智能使用Java语言；

   + 数据库连接池如果要换，对整体应用都需要做很大的改动，然后还要担心性能和稳定性，整个系统会不会出新的bug

   **就是很畏手畏脚的更新技术**

   > 还有一点，数据库只能选择固定的存储方式，其实有的数据适合Redis存储，有的适合mongodb存储

## 微服务架构的特征

> **In short, the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.** 

上面是 [Martin Fowler](https://martinfowler.com/) 大叔对微服务架构风格的描述，简单概括如下：

+ 将原有单体应用拆分成多个小的服务
+ 每个服务作为单独一个进程存在，服务与服务之间通过轻量级的方法通信，比如HTTP
+ 每个服务可独立部署，并且是采用自动化的部署方式
+ 对于这些服务要去中心化管理，让其自治，并且每个服务可以采用不同的编程语言和不同的数据存储技术

下面对上述简述作进一步说明

### 微服务架构使用服务作为组件化的单元

+ 在微服务架构中，组件的单元变成了服务
+ 服务运行在独立的进程，需要类似HTTP这样的进程通信方式
+ 每个服务可独立部署，需要对其他服务暴露API接口
+ 服务与服务之间只能通过API访问另外的服务，并不能访问其内部代码和数据存储中心

### 微服务架构的开发团队围绕业务能力来组织

+ 单体应用的开发团队按照**技能**来划分，一般分为前端开发，后端开发和数据库管理等

+ 微服务架构的开发团队以**服务为单元来组织**，每个服务与特定的业务需求相对应

  > 微服务的开发团队包含开发、测试和DevOps相关的全部人员
  >
  > 某个微服务的开发团队人员较少，小团队沟通成本更低，开发效率相对来说更高

### 微服务使用去中心化的管理模式

+ 微服务架构中的服务可独立部署，可采用不同的技术栈开发

+ 每个团队自主管理所负责的服务，不但负责构建，还同样负责运行和维护，这样提高了团队的自主性和主观能动性，降低了管理的成本

### 微服务采用去中心的数据存储

微服务可以采取最适合自己的数据存储方式，有更多的选择自由

### 微服务强调基础设施自动化

+ 微服务应用可独立部署，所以服务实例较多时，需要自动化部署
+ 持续集成和持续部署都是微服务通用的实践

### 微服务架构在设计时充分考虑到失败的情况

微服务之间的交互通过进程间通信来完成，所以要考虑交互失败的情况

## 微服务架构的问题

### 最大的问题：微服务本身实现的复杂性

使用微服务架构后，系统整体变成了一个分布式系统，分布式系统是特别复杂的

### 如何划分微服务

### 数据的一致性

**服务可能使用不同的数据存储（关系型数据库和No SQL数据库），在不同的数据存储中，如何保证数据的一致性**

+ 在单体应用中可以通过ACID保证数据的一致性
+ 在微服务架构中，通常保证的是数据**最终一致性**

### 微服务架构对运维提出了更高的要求

### 微服务面临的挑战

+ 注册与发现

  > 为什么需要注册中心，因为服务实例是动态变化的，而不是固定不变的。

+ 路由

+ 可靠性

  > 进程内的调用除非进程终止了，否则一般都是可靠的；

  > 服务之间跨进程的调用会因各种原因而不可靠

+ 延迟

  服务调用会因网络，序列化等原因而延迟

+ 热点

  负载均衡用来解决热点问题。

+ 短路

  保护服务

+ 伸缩

  > Docker容器

+ 异步

  消息只是异步的一种形式。

+ 监控

+ 配置

  分布式配置Spring Cloud Config

  > **配置文件修改后，要立即同步到应用中。**

+ 数据同步
  
+ CAP原则
  
+ 安全

+ Web前端：XSS 

+ 认证鉴权；服务之间是否有权限，第三方认证登陆

## 微服务架构的实现

![微服务架构的实现](https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/第01讲：什么是微服务架构_24.png)

## 微服务的技术选择

+ Netflix OSS

+ Spring Cloud  

  + Based on Spring Framework 
  + Spring Cloud Commons

+ Kebernetes 

  > **管理容器化工作负载和服务的平台，同时也是容器编排平台**

# Docker与容器化技术简介

微服务架构应用的本质是**分布式系统**，微服务实例很多，数据存储中间件，消息中间件等都很多，对运维也提出了更高的要求，微服务架构应用的部署离不开容器应用。

## 应用部署技术的发展

![应用部署技术的发展](https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/应用部署方式演进图.png)

### 硬件虚拟化

+ 硬件虚拟化指的是对计算机的虚拟化，虚拟化对用户隐藏了计算平台的物理特征，仅仅提供一个抽象的计算平台。

+ 用来控制虚拟化的程序称为 **Hypervisor**，它可以创建和运行虚拟机 

+ 在虚拟机上可以安装不同类型的操作系统，包括 Windows、Linux 和 MacOS 

+ **虚拟机实例共享虚拟化的硬件资源** 

总结一下：其实就是先在操作系统上安装**Hypervisor**，然后根据需要创建和运行虚拟机，在虚拟机上创建操作系统，然后在操作系统里运行应用。

**缺点：**

硬件虚拟化的不足之处在于**只能以操作系统为单位进行扩展，操作系统本身也需要资源。**

> 我的理解是 虚拟机实例中需要创建操作系统后才能运行应用程序，而操作系统也需要资源，并不是所有资源都给了我们的应用。

### 容器化技术

#### 传统部署流程的问题

早期软件开发实践，开发团队的成员在本地环境开发，然后通过持续集成环境构建出可部署的工件（Artifact）；部署的工作交给运维团队来完成，根据开发团队的文档安装应用及应用所依赖的外部服务，如数据库和消息中间件等。

> 如果开发团队的文档有误，就会导致运维团队安装的生产环境应用出现问题

这样的开发方式及其容易造成**本地开发环境和线上运行环境**的不一致，很多情况下本地是好的，线上就是有问题。

![](https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/传统部署方式.png)

#### 容器化技术的优点

容器化技术提供了一种**更简洁的方式**来描述可运行的应用。

我们可以不用给运维团队提供参数，将参数直接内置在应用中，不就可以了嘛！:kissing_smiling_eyes:这就是**镜像文件**。

![](https://liutianruo-2019-go-go-go.oss-cn-shanghai.aliyuncs.com/images/容器化部署方式.png)



**容器化最大的优势是不可变！**在进行版本更新时，如果出现没有预料到的问题，可以使用上一个版本的镜像重新运行容器，就可以实现版本快速回退。

> 容器的不变性是实现开发环境、测试环境和线上环境一致的前提
>
> 类似于多线程场景下，某个值是只读的、不会被修改，那和它相关的场景**一般情况下**应该是线程安全的。

还有一点，如果生产环境出现问题，我们可以把镜像拿到本地环境来测试。

##### 容器化解决了不同环境之间的一致性问题

开发环境产出的应用镜像，经过测试团队的测试后被部署到生产环境中

**此时开发、测试和生产环境使用的是同样的镜像。**

## Docker的基本概念

Docker中最重要的概念是**镜像**和**容器**。

+ **镜像**是创建容器的只读模板，可以从 Docker 注册表中下载，也可以创建自定义镜像 

  > Docker Hub 是默认的镜像注册表，包含了非常多可用的镜像，企业内部也可以搭建自己私有的注册表 

  > 通常创建镜像的方式：在已有的镜像上进行定制，得到新的镜像 

+ **容器**是镜像的可运行实例，从镜像中创建出来的容器，可以被启动、暂停、停止和删除

> 镜像可以比作一个程序，而容器可以比作运行时的程序，也就是进程。

## Docker的安装

+ Windows平台

  + win10专业版 可安装 Docker Desktop

  + win10家庭版 可安装 Docker Toolbox 

    > Docker Toolbox 内嵌了Git、Oracle VM VirtualBox

+ Linux  安装 Docker Engine

## 关于Docker的操作，后续更新

## 云原生应用的15个特征

TODO

## Kebernetes容器化应用